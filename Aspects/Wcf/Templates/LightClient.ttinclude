<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="EnvDTE" #>
<#@ Assembly Name="EnvDTE80" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\\..\\Aspects\\Templates\\CommonUtilities.ttinclude" #><#

    const string InterfaceDirSuffix1 = "Services";
    const string InterfaceDirSuffix2 = "Service";
    const string InterfaceDirSuffix3 = "ServiceContracts";
    const string InterfaceDirSuffix4 = "ServiceContract";

    DTE dte = GetEnvDte();

    var templateFullName = GetTemplateFullName(dte);

    var templateDirName  = Path.GetDirectoryName(templateFullName);
    var templateName     = Path.GetFileName(templateFullName);
    
    var baseName         = templateName.Replace("Client.tt", "");
    var sourceName       = "I" + baseName + ".cs";
    var sourceFullName   = Path.GetFullPath(
                                GetExistingFile(
                                    () => Path.Combine(templateDirName, sourceName),
                                    () => Path.Combine(templateDirName, "..", sourceName),
                                    () => Path.Combine(templateDirName, "..", InterfaceDirSuffix1, sourceName),
                                    () => Path.Combine(templateDirName, "..", InterfaceDirSuffix2, sourceName),
                                    () => Path.Combine(templateDirName, "..", InterfaceDirSuffix3, sourceName),
                                    () => Path.Combine(templateDirName, "..", InterfaceDirSuffix4, sourceName)));

    var codeModel        = dte.Solution.FindProjectItem(sourceFullName).FileCodeModel;
    var codeNamespace    = codeModel.CodeElements.OfType<CodeNamespace>().FirstOrDefault();
    var codeInterface    = codeNamespace.Children.OfType<EnvDTE.CodeInterface>().FirstOrDefault();
    var codeNamespaceStr = codeNamespace.FullName;

    if (templateDirName != Path.GetDirectoryName(sourceFullName))
        codeNamespaceStr = codeNamespaceStr.Substring(0, codeNamespaceStr.LastIndexOf('.')) + ".Clients";

    WriteUsings(
        codeModel.CodeElements,
        "System.Security.Cryptography.X509Certificates",
        "System.ServiceModel.Channels",
        "vm.Aspects.Wcf",
        "vm.Aspects.Wcf.Clients",
        codeNamespace.FullName);

    // WriteLine("");
    // WriteLine("namespace {0}", codeNamespaceStr);
    // WriteLine("{");
    // PushIndent("    ");
    // 
    // WriteLine("public class {0}Client : LightClient<I{0}>, I{0}", baseName);
    // WriteLine("{");
    // PushIndent("    ");
#>

namespace <#= codeNamespaceStr #>
{
    public class <#= baseName #>Client : LightClient<I<#= baseName #>>, I<#= baseName #>
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="T:<#= baseName #>Client{TContract}" /> class (creates the channel factory)
        /// from an endpoint configuration section given by the <paramref name="endpointConfigurationName" /> and service address.
        /// </summary>
        /// <param name="endpointConfigurationName">Name of the endpoint configuration.</param>
        /// <param name="remoteAddress">The remote address. If the remote address is <see langword="null" /> or empty
        /// the constructor will try to use the address in the endpoint configuration.</param>
        public <#= baseName #>Client(
            string endpointConfigurationName,
            string remoteAddress)
            : base(endpointConfigurationName, remoteAddress)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="T:<#= baseName #>Client{TContract}" /> class (creates the channel factory).
        /// </summary>
        /// <param name="remoteAddress">The remote address of the service.</param>
        /// <param name="identityType">
        /// Type of the identity: can be <see cref="ServiceIdentity.Dns" />, <see cref="ServiceIdentity.Spn" />, <see cref="ServiceIdentity.Upn" />, or 
        /// <see cref="ServiceIdentity.Rsa" />.
        /// </param>
        /// <param name="identity">
        /// The identifier in the case of <see cref="ServiceIdentity.Dns" /> should be the DNS name of specified by the service's certificate or machine.
        /// If the identity type is <see cref="ServiceIdentity.Upn" /> - use the UPN of the service identity; if <see cref="ServiceIdentity.Spn" /> - use the SPN and if
        /// <see cref="ServiceIdentity.Rsa" /> - use the RSA key.
        /// </param>
        public <#= baseName #>Client(
            string remoteAddress,
            ServiceIdentity identityType,
            string identity)
            : base(remoteAddress, identityType, identity)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="T:<#= baseName #>Client{TContract}" /> class.
        /// </summary>
        /// <param name="remoteAddress">The remote address of the service.</param>
        /// <param name="identityType">
        /// Type of the identity: can be <see cref="ServiceIdentity.Certificate" /> or <see cref="ServiceIdentity.Rsa" />.
        /// </param>
        /// <param name="certificate">The identifying certificate.</param>
        public <#= baseName #>Client(
            string remoteAddress,
            ServiceIdentity identityType,
            X509Certificate2 certificate)
            : base(remoteAddress, identityType, certificate)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="T:<#= baseName #>Client{TContract}" /> class (creates the channel factory).
        /// </summary>
        /// <param name="binding">A binding instance.</param>
        /// <param name="remoteAddress">The remote address of the service.</param>
        /// <param name="identityType">
        /// Type of the identity: can be <see cref="ServiceIdentity.Dns" />, <see cref="ServiceIdentity.Spn" />, <see cref="ServiceIdentity.Upn" />, or 
        /// <see cref="ServiceIdentity.Rsa" />.
        /// </param>
        /// <param name="identity">
        /// The identifier in the case of <see cref="ServiceIdentity.Dns" /> should be the DNS name of specified by the service's certificate or machine.
        /// If the identity type is <see cref="ServiceIdentity.Upn" /> - use the UPN of the service identity; if <see cref="ServiceIdentity.Spn" /> - use the SPN and if
        /// <see cref="ServiceIdentity.Rsa" /> - use the RSA key.
        /// </param>
        public <#= baseName #>Client(
            Binding binding,
            string remoteAddress,
            ServiceIdentity identityType,
            string identity)
            : base(binding, remoteAddress, identityType, identity)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="T:<#= baseName #>Client{TContract}" /> class.
        /// </summary>
        /// <param name="binding">A binding instance.</param>
        /// <param name="remoteAddress">The remote address of the service.</param>
        /// <param name="identityType">
        /// Type of the identity: can be <see cref="ServiceIdentity.Certificate" /> or <see cref="ServiceIdentity.Rsa" />.
        /// </param>
        /// <param name="certificate">The identifying certificate.</param>
        public <#= baseName #>Client(
            Binding binding,
            string remoteAddress,
            ServiceIdentity identityType,
            X509Certificate2 certificate)
            : base(binding, remoteAddress, identityType, certificate)
        {
        }
        #endregion

        #region I<#= baseName #> implementation
<#
    PushIndent("    ");
    PushIndent("    ");
    
    SeparatedList(
        codeInterface.Members.OfType<CodeFunction>(),
        m => WriteMethod(m),
        () => WriteLine(""));

    WriteLine("#endregion");

    PopIndent();
    WriteLine("}");

    PopIndent();
    WriteLine("}");
#><#+

    void WriteMethod(CodeFunction method)
    {
        WriteDoc(method.DocComment);

        var type = GetType(method.Type as CodeTypeRef2);
        var isAsync = type == "Task"  || type.StartsWith("Task<");

        Write("public {0}{1} {2}", isAsync ? "async " : "", type, method.Name);
        WriteLine("(");

        // write parameters
        PushIndent("    ");
        SeparatedList(
            method.Parameters.OfType<CodeParameter>(),
            p => Write("{0} {1}", GetType(p.Type), p.Name),
            () => WriteLine(","));
        PopIndent();
        WriteLine(")");
        WriteLine("{");
        PushIndent("    ");
        if (type != "void"  &&  type != "Task")
            Write("return ");
        Write("{0}Proxy.{1}(", isAsync ? "await " : "", method.Name);
        // write arguments
        SeparatedList(
            method.Parameters.OfType<CodeParameter>(),
            p => Write("{0}", p.Name),
            () => Write(", "));
        WriteLine(");");
        PopIndent();
        WriteLine("}");
    }
#>